;; Contract: compute_longest : ((number number), ...) * number * number -> number
;; Purpose: to compute the length of the longest non-desc sublist that ends at curr
;; Example: (compute_longest `(1 2 3 4) 4 1) should produce 4
;; Definition:
(define (compute_longest lst curr longest )
	(if (null? lst)
		; if lst is null, return input longest value
		longest

		; if not null, compare head of lst
		(if 
			(and 
				(>= curr (caar lst))
				(< longest (+ (cadar lst) 1) )
			)

			(compute_longest
				(cdr lst)
				curr
				(+ longest 1)
			)

			(compute_longest
				(cdr lst)
				curr
				longest
			)
		)
	)
)

;; Contract: shape : (numbers) -> ( (number), (number), ... )
;; Purpose: Make each number in lst a separate list that contains the number
;; Example: (shape `(1 2 3)) should produce ( (1) (2) (3) )
;; Definition:
(define (shape lst)
	(if (= (length lst) 1)
		(list lst)
		(cons (list (car lst)) (shape (cdr lst)))
		)
	)



;; Contract: generate_sublists : (numbers) * number -> ((numbers), ...)
;; Purpose: to compute all possible sublists of lst with a specific length len
;; Example: (generate_sublists `(3 2 1) 2) should produce ( (3 2) (3 1) (2 1) )
;; Definition:
(define (generate_sublists lst len)
	(cond

		; if len = 0, return empty list

		( (= len 1)
			(shape lst)
		)


		; if len = length of the list, return
		;  the whole lis
		( (= len (length lst))
			(list lst)
			)

		(else
			(append
				; idea:
				; 	for each list generated by recursion with len -1
				;	 add car lst back in
				(map

					; add (car lst) in front of l
					(lambda (l)
						(cons
							(car lst)
							l
						)
					)

					; sublists --> l
					(generate_sublists
						(cdr lst)
						(- len 1)
					)
				)


				; change the starting point of sublists
				;  because essentially the starting point
				;   is car lst
				(generate_sublists
					(cdr lst)
					len
				)

			)
		)
	)
)

;; Contract: is_non_desc : (numbers) * number -> boolean
;; Purpose: check if the list lst is non-descending, given the previous element curr
;; Example: (is_non_desc `(2 3 1) 1) should produce #f
;; Definition:
(define (is_non_desc lst curr)
	(cond
		( (null? lst)
			#t
		)

		( (< (car lst) curr)
			#f
		)

		(else
			(is_non_desc
				(cdr lst)
				(car lst)
			)
		)
	)
)

;; Contract: is_non_desc_driver : (numbers) -> boolean
;; Purpose: driver function for is_non_desc
;; Example: (is_non_desc `(1 2 3 1)) should produce #f
;; Definition:
(define (is_non_desc_driver lst)
	(if (= (length lst) 1)
		#t

		(is_non_desc
			(cdr lst)
			(car lst)
		)
	)
)

;; lst --> list of sublists
;; Contract: get_first_non_desc : ((numbers), ...) -> (numbers)
;; Purpose: Find the first non-descending list in a list of lists
;; Example: (get_first_non_desc `( ( 3 2 1 ) ( 2 2 1) ( 1 2 3 ) ) ) should produce (1 2 3)
;; Definition:
(define (get_first_non_desc lst)
	(if (null? lst)
		`()

		; if first sublist is non-desc, return that list
		;  otherwise check the remaining ones
		(if (is_non_desc_driver (car lst))
			(car lst)
			(get_first_non_desc (cdr lst))
		)
	)
)

;; Contract: ((numbers), ...) * number -> (numbers)
;; Purpose: to compute the greatest non-desc sublist of lst with length len
;; Example: (slow `(1 2 3 4 1) 4) should produce (1 2 3 4)
;; Definition:
(define (slow lst len)
	(if (<= (length lst) 0)
		`()
		; first_lst --> first non-desc sublist of all sublists generated by lst and len
		(let ( ( first_lst ( get_first_non_desc (generate_sublists lst len) ) ) )

			; if no such sublist exists, recurse
			(if (null? first_lst)
				(slow lst (- len 1))
				first_lst
			)
		)
	)
)

;; Contract: lis_slow : list_of_numbers -> list_of_numbers
;; Purpose: to compute the greatest non-descending subsequence of the input list in O(2^n) time
;; Example: (lis_slow `(1 2 3 4 1)) should produce (1 2 3 4)
;; Definition:
(define (lis_slow lst)
	(slow lst (length lst))
)

;; Contract: lis_fast : list_of_numbers -> list_of_numbers
;; Purpose: to compute the greates non-descending subsequence of the input list in polynomial time
;; Example: (lis_fast `(1 2 3 4 1)) should produce (1 2 3 4)
;; Definition:
(define (lis_fast lst)
	(if (null? lst)
		`()
		(let* ( (l (compute_group `() lst) ) (max_l (max_j l) ) )
			(get_sublst
				l
				1
				`()
				max_l
			)
		)
	)
)

(define (compute_group group L)
  (if (= (length L) 1)
   (list (list
          (car L)
          (compute_longest group (car L) 1)))
   ; base case, return the last desired pair of the list
   (append (list (list
                  (car L)
                  (compute_longest group (car L) 1)))
           ;the first element of append, the pair of the current element and the corresponding L(k)
           (compute_group
            (append group
                    (list (list
                           (car L)
                           (compute_longest group (car L) 1))))
            (cdr L)))
            ;the second element of append, the remaining L which is the result of recursion
   )
  )

;; Contract: max_j : ((number number), ...) -> number
;; Purpose: to compute the length of greatest non-descending subsequence of the input list
;; Example: (max_j `((1 1) (2 2) (3 3) (4 4) (1 2))) should produce 4
;; Definition:
(define (max_j seq)
        (if (equal? (cdr seq) '())
            (car (cdr (car seq)))
            (max (car (cdr (car seq))) (max_j (cdr seq)))
        )
)

;; Contract: crop_lst : ((number number), ...) * number -> ((number number), ...)
;; Purpose: to find the element with given length index and crop the input list to get a new list starting at the element
;; Example: (crop_lst `((1 1) (2 2) (3 3) (4 4) (1 2)) 3) should produce ((3 3) (4 4) (1 2))
;; Definition:
(define (crop_lst lst j)
	    (if (equal? lst '())
	    	'()
			(if (equal? (car (cdr (car lst))) j)
            	lst
            	(if (equal? (cdr lst) '())
                	'()
                	(crop_lst (cdr lst) j)
            	)
        	)
        )
)

;; Contract: get_sublst : ((number number), ...) * number * (number number, ...) * number -> (number number, ...)
;; Purpose: to extract the greatest non-descending subsequence from the given length-indexed list
;; Example: (get_sublst `((1 1) (2 2) (3 3) (4 4) (1 2)) 1 '() 4) should produce (1 2 3 4)
;; Definition:
(define (get_sublst lst j sublst last_j)
        ; if length of sublst = last_j, then greatest non-descending subsequence is succefully extracted
        (if (equal? (length sublst) last_j)
            (reverse sublst)
            ; use crop_lst to find the next element with index j
            (let ((x (crop_lst lst j)))
                  ; if j-indexed element is not found, return null as false alert
                  (cond ((equal? x '()) '())
                        ; if j=1, we're processing the first element, then do not check non-descending
                        ((equal? j 1) (let ((y (get_sublst (cdr x) (+ j 1) (cons (car (car x)) sublst) last_j)))
                                            (cond ((equal? y '()) (get_sublst (cdr x) j sublst last_j))
                                                  (else y
                                                  )
                                            )
                                      ))
                        ; if j!=1, check if the next element found is greater or equal to the previous element
                        (else
                            (cond ((< (car (car x)) (car sublst)) (get_sublst (cdr x) j sublst last_j))
                                  (else
                                      ; recursively call the function to find the next element
                                      (let ((y (get_sublst (cdr x) (+ j 1) (cons (car (car x)) sublst) last_j)))
                                            ; if the next iterations returns null, try finding a new element at the current iteration
                                            (cond ((equal? y '()) (get_sublst (cdr x) j sublst last_j))
                                                  ; or answers found
                                                  (else y
                                                  )
                                            )
                                      )
                                  )
                            )
                        )
                 )
            )
         )
)
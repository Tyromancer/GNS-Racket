;; lst --> ( (num longest), ... )
;; curr --> current number in input list
;; longest --> curr's longest val
(define (compute_longest lst curr longest )
	(if (null? lst)
		; if lst is null, return input longest value
		longest

		; if not null, compare head of lst
		(if 
			(and 
				(>= curr (caar lst))
				(< longest (+ (cadar lst) 1) )
			)

			(compute_longest
				(cdr lst)
				curr
				(+ longest 1)
			)

			(compute_longest
				(cdr lst)
				curr
				longest
			)
		)
	)
)

(define (shape lst)
	(if (= (length lst) 1)
		(list lst)
		(cons (list (car lst)) (shape (cdr lst)))
		)
	)




(define (generate_sublists lst len)
	(cond

		; if len = 0, return empty list

		( (= len 1)
			(shape lst)
		)


		; if len = length of the list, return
		;  the whole lis
		( (= len (length lst))
			(list lst)
			)

		(else
			(append
				; idea:
				; 	for each list generated by recursion with len -1
				;	 add car lst back in
				(map

					; add (car lst) in front of l
					(lambda (l)
						(cons
							(car lst)
							l
						)
					)

					; sublists --> l
					(generate_sublists
						(cdr lst)
						(- len 1)
					)
				)


				; change the starting point of sublists
				;  because essentially the starting point
				;   is car lst
				(generate_sublists
					(cdr lst)
					len
				)

			)
		)
	)
)

;; Contract: is_non_desc : list_of_numbers number -> boolean
;; Purpose: check if the list is non-descending, given the previous element
;; Example: (is_non_desc `(2 3 1) 1) should produce #f
;; Definition
(define (is_non_desc lst curr)
	(cond
		( (null? lst)
			#t
		)

		( (< (car lst) curr)
			#f
		)

		(else
			(is_non_desc
				(cdr lst)
				(car lst)
			)
		)
	)
)

;; Contract: is_non_desc_driver : list_of_numbers -> boolean
;; Purpose: driver function for is_non_desc
;; Example: (is_non_desc `(1 2 3 1)) should produce #f
;; Definition
(define (is_non_desc_driver lst)
	(if (= (length lst) 1)
		#t

		(is_non_desc
			(cdr lst)
			(car lst)
		)
	)
)

;; lst --> list of sublists
(define (get_first_non_desc lst)
	(if (null? lst)
		`()

		; if first sublist is non-desc, return that list
		;  otherwise check the remaining ones
		(if (is_non_desc_driver (car lst))
			(car lst)
			(get_first_non_desc (cdr lst))
		)
	)
)


(define (slow lst len)
	(if (<= (length lst) 0)
		`()
		; first_lst --> first non-desc sublist of all sublists generated by lst and len
		(let ( ( first_lst ( get_first_non_desc (generate_sublists lst len) ) ) )

			; if no such sublist exists, recurse
			(if (null? first_lst)
				(slow lst (- len 1))
				first_lst
			)
		)
		; (append
		; 	(generate_sublists
		; 		lst
		; 		len
		; 	)

		; 	(slow
		; 		lst
		; 		(- len 1)
		; 	)
		; )
	)
)

;; Contract: lis_slow : list_of_numbers -> list_of_numbers
;; Purpose: to compute the greates non-descending subsequence of the input list in O(2^n) time
;; Example: (lis_slow `(1 2 3 4 1)) should produce (1 2 3 4)
;; Definition
(define (lis_slow lst)
	(slow lst (length lst))
)

;; Contract: lis_fast : list_of_numbers -> list_of_numbers
;; Purpose: to compute the greates non-descending subsequence of the input list in polynomial time
;; Example: (lis_fast `(1 2 3 4 1)) should produce (1 2 3 4)
;; Definition
(define (lis_fast lst)
	(if (null? lst)
		`()
		(let* ( (l (compute_group `() lst) ) (max_l (max_j l) ) )
			(get_sublst
				l
				1
				`()
				max_l
			)
		)
	)
)

(define (compute_group group L)
  (if (= (length L) 1)
   (list (list
          (car L)
          (compute_longest group (car L) 1)))
   ; base case, return the last desired pair of the list
   (append (list (list
                  (car L)
                  (compute_longest group (car L) 1)))
           ;the first element of append, the pair of the current element and the corresponding L(k)
           (compute_group
            (append group
                    (list (list
                           (car L)
                           (compute_longest group (car L) 1))))
            (cdr L)))
            ;the second element of append, the remaining L which is the result of recursion
   )
  )


(define (max_j seq)
        (if (equal? (cdr seq) '())
            (car (cdr (car seq)))
            (max (car (cdr (car seq))) (max_j (cdr seq)))
        )
)

(define (crop_lst lst j)
	    (if (equal? lst '())
	    	'()
			(if (equal? (car (cdr (car lst))) j)
            	lst
            	(if (equal? (cdr lst) '())
                	'()
                	(crop_lst (cdr lst) j)
            	)
        	)
        )
)

(define (get_sublst lst j sublst last_j)
        (if (equal? (length sublst) last_j)
            (reverse sublst)
            (let ((x (crop_lst lst j)))
                  (cond ((equal? x '()) '())
                        ((equal? j 1) (let ((y (get_sublst (cdr x) (+ j 1) (cons (car (car x)) sublst) last_j)))
                                            (cond ((equal? y '()) (get_sublst (cdr x) j sublst last_j))
                                                  (else y
                                                  )
                                            )
                                      ))
                        (else
                            (cond ((< (car (car x)) (car sublst)) (get_sublst (cdr x) j sublst last_j))
                                  (else
                                      (let ((y (get_sublst (cdr x) (+ j 1) (cons (car (car x)) sublst) last_j)))
                                            (cond ((equal? y '()) (get_sublst (cdr x) j sublst last_j))
                                                  (else y
                                                  )
                                            )
                                      )
                                  )
                            )
                        )
                 )
            )
         )
)
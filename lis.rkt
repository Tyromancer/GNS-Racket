(define (generate_sublists lst len)
	(cond

		; if len = 0, return empty list
		( (= len 0)
			`()
		)

		; if len = length of the list, return
		;  the whole list
		( (= (length lst) len)
			(list lst)
		)

		(else
			(append

				; idea:
				; 	for each list generated by recursion with len -1
				;	 add car lst back in
				(map

					; add (car lst) in front of l
					(lambda
						(l)
						(cons
							(car lst)
							l
						)
					)

					; sublists --> l
					(generate_sublists
						(cdr lst)
						(- len 1)
					)
				)

				; change the starting point of sublists
				;  because essentially the starting point
				;   is car lst
				(generate_sublists
					(cdr lst)
					len
				)
			)
		)
	)
)

;; Contract: is_non_desc : list_of_numbers number -> boolean
;; Purpose: check if the list is non-descending, given the previous element
;; Example: (is_non_desc `(2 3 1) 1) should produce #f
;; Definition
(define (is_non_desc lst curr)
	(cond
		( (null? lst)
			#t
		)

		( (< (car lst) curr)
			#f
		)

		(else
			(is_non_desc
				(cdr lst)
				(car lst)
			)
		)
	)
)

;; Contract: is_non_desc_driver : list_of_numbers -> boolean
;; Purpose: driver function for is_non_desc
;; Example: (is_non_desc `(1 2 3 1)) should produce #f
;; Definition
(define (is_non_desc_driver lst)
	(if (= (length lst) 1)
		#t

		(is_non_desc
			(cdr lst)
			(car lst)
		)
	)
)

;; lst --> list of sublists
(define (get_first_non_desc lst)
	(if (null? lst)
		`()

		; if first sublist is non-desc, return that list
		;  otherwise check the remaining ones
		(if (is_non_desc_driver (car lst))
			(car lst)
			(get_first_non_desc (cdr lst))
		)
	)
)

(define (slow lst len)
	(if (<= (length lst) 0)
		`()
		; first_lst --> first non-desc sublist of all sublists generated by lst and len
		(let ( ( first_lst ( get_first_non_desc (generate_sublists lst len) ) ) )

			; if no such sublist exists, recurse
			(if (null? first_lst)
				(slow lst (- len 1))
				first_lst
			)
		)
	)
)

;; Contract: lis_slow : list_of_numbers -> list_of_numbers
;; Purpose: to compute the greates non-descending subsequence of the input list in O(2^n) time
;; Example: (lis_slow `(1 2 3 4 1)) should produce (1 2 3 4)
;; Definition
(define (lis_slow lst)
	(slow lst (length lst))
)

;; Contract: lis_fast : list_of_numbers -> list_of_numbers
;; Purpose: to compute the greates non-descending subsequence of the input list in polynomial time
;; Example: (lis_fast `(1 2 3 4 1)) should produce (1 2 3 4)
;; Definition
(define (lis_fast lst)
	; TODO
)
